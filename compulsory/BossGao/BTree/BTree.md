# B树
### 前言

```
	动态查找树主要有：二叉查找树、平衡二叉树、红黑树、B树、B+树。
前面三种是典型的二叉查找树查找的时间复杂度是O(log2N)与树的深度有关系，
那么降低树的深度也就可以提升查找效率。
这时就提出了平衡多路查找树，也就是B树以及B+树。
B树和B+树非常典型的场景就是用于关系型数据库的索引(MySQL)

```

## B树

> B树是一种平衡多路搜索树，B树与红黑树最大的不同在于，B树的结点可以有多个子女，从几个到几千个。
> > <font size=3 color="red">具体定义:</font>
> >
> * 根节点至少有两个子节点
> * 每个节点有M-1个key，并且以升序排列
> * 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
> * 其它节点至少有M/2个子节点
> * 所有叶子结点位于同一层
> 
> > <font size=3 color="red">B树的特性:</font>
> > 
> > * 关键字集合分布在整颗树中；
> > * 任何一个关键字出现且只出现在一个结点中；
> > * 搜索有可能在非叶子结点结束(树中所有结点都存储数据，与B+树这一点不同)；
> > * 其搜索性能等价于在关键字全集内做一次二分查找；

* B树插入演示：
插入（6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4）

<iframe height=300 width=800 src="https://files.cnblogs.com/files/yangecnu/btreebuild.gif"></iframe>

[点击查看动态演示](https://files.cnblogs.com/files/yangecnu/btreebuild.gif)

<br/>

## B-树
> 是一种多路搜索树（并不是二叉的）
> > 
> > <font size=3 color="red">具体定义:</font>
> > 
> > * 定义任意非叶子结点最多只有M个儿子；且M>2；
> > * 根结点的儿子数为[2, M]；
> > * 除根结点以外的非叶子结点的儿子数为[M/2, M]；
> > * 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
> > * 非叶子结点的关键字个数=指向儿子的指针个数-1；
> > * 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
> > * 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
> > * 所有叶子结点位于同一层；
> 
> > <font size=3 color="red">B-树的特性:</font>
> >
> > * 关键字集合分布在整颗树中；
> > * 任何一个关键字出现且只出现在一个结点中；
> > * 搜索有可能在非叶子结点结束；
> > * 其搜索性能等价于在关键字全集内做一次二分查找；
> > * 自动层次控制；

```
由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：
	其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；
	由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；

```

<br/>

## B+数

> B+树是B-树的变体，也是一种多路搜索树
> 
> > <font size=3 color="red">具体定义:</font>
> > 
> > * 其定义基本与B-树同，除了：
> > * 非叶子结点的子树指针与关键字个数相同；
> > * 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树(B-树是开区间）；
> > * 为所有叶子结点增加一个链指针；
> > * 所有关键字都在叶子结点出现；
> > 
> > <font size=3 color="red">B+树的特性:</font>
> > 
> > * 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
> > * 不可能在非叶子结点命中；
> > * 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储关键字）数据的数据层；
> > * 更适合文件索引系统；

<br/>

## B*树

> 是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针
> 
> > <font size=3 color="red">具体定义:</font>
> > 
> > * B* 树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）
 
```
B+树的分裂：
	当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

B* 树的分裂：
	当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；所以，B*树分配新结点的概率比B+树要低，空间使用率更高；
	
```

<br/>

## 总结

* **B树**：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；

* **B-树**：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所			有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

* **B+树**：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作		为叶子结点的索引；B+树总是到叶子结点才命中；

* **B*树**：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；


<br/>

# 参考资料

[参考博客](https://blog.csdn.net/u010853261/article/details/78217823)































