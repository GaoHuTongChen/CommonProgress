# MySQL索引

### 前言

```
数据库的性能主要取决于引擎，但是在业务上往往依赖于引擎以外的索引/IO等优化来达到快速响应和数据分析（目前主流有引擎有InnoDB和MyISAM）。
本文主要讲述索引相关的优化。

```

### MySQL引擎对比（附）
| 功能  | MYISAM  | Memory | InnoDB | Archive |
|:------ |----------:| ----------:| ------:| ---:|
| 存储限制 | 256TB	|RAM | 64TB | None |
| 支持事物	| No | No	| Yes	| No |
| 支持全文索引 | Yes | No	 | No	| No |
| 支持数索引 | Yes	 | Yes	 | Yes | No |
| 支持哈希索引 | No | Yes | No | No |
| 支持数据缓存 | No | N/A	 | Yes | No |
| 支持外键	| No | No | Yes | No |

## Mysql索引结构（主要有两种结构）

* <font size=5 > B+Tree索引 </font>
>
> B+tree是mysql使用最频繁的一个索引数据结构，是Inodb和Myisam存储引擎模式的索引类型。相对Hash索引，B+树在查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作； B+Tree所有索引数据都在叶子结点上，并且增加了顺序访问指针,每个叶子节点都有指向相邻叶子节点的指针；减少磁盘I/O读取（数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入即每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O）。
>

* <font size=5 > Hash索引 </font>
>
> MySQL中，只有Memory（Memory表只存在内存中，断电会消失，适用于临时表）存储引擎显示支持Hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B+Tree索引。hsah索引把数据的索引以hash形式组织起来，因此当查找某一条记录的时候,速度非常快。当时因为是hash结构，每个键只对应一个值，而且是散列的方式分布。所以他并不支持范围查找和排序等功能。
>

* <font size=5 > 全文索引 </font>
>
> 全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文索引和其他几种索引的匹配方式完全不一样，它更类似于搜索引擎做的事情，而不是简单的where条件匹配。可以在相同的列上，同时创建全文索引和B-Tree索引，全文索引适用于 Match Against 操作，而不是普通的where条件操作。
>

## Mysql常见索引

* <font size=5 > 索引创建 </font>
>
> PRIMARY KEY（主键索引）  ALTER TABLE `table_name` ADD PRIMARY KEY ( `col` ) 
>
> UNIQUE(唯一索引)     ALTER TABLE `table_name` ADD UNIQUE (`col`)
> 
> INDEX(普通索引)     ALTER TABLE `table_name` ADD INDEX index_name (`col`)
>
> FULLTEXT(全文索引)      ALTER TABLE `table_name` ADD 
> 
> FULLTEXT ( `col` ) 组合索引   ALTER TABLE `table_name` ADD INDEX index_name (`col1`, `col2`, `col3` ) 
>


* <font size=5 > 索引对比 </font>
>
> | 索引类型 | 描述 |
> |:----------:|:------------| 
> |普通索引 | 最基本的索引，没有任何限制 |
> |唯一索引 | 与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。|
> |主键索引 | 它是一种特殊的唯一索引，不允许有空值。 |
> |全文索引 | 仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时好空间。|
> |组合索引 | 为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。创建复合索引时应该将最常用（频率）作限制条件的列放在最左边，依次递减|
>

* <font size=5 > 索引的数据类型 </font>
>
> MySQL支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。通常来说，一下原则供参考：
> 
> * 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。
> * 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。（在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。）
> * 尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。
> 
> 
> 主键类型：（建议整型）
> 
> * (1)整型：通常是作为标识符的最好选择，因为可以更快的处理，而且可以设置为AUTO_INCREMENT。
> * (2)字符串：尽量避免使用字符串作为标识符，它们消耗更好的空间，处理起来也较慢。而且，通常来说，字符串都是随机的，所以它们在索引中的位置也是随机的，这会导致页面分裂、随机访问磁盘，聚簇索引分裂（对于使用聚簇索引的存储引擎）。
> 

## Mysql索引设计
> 
> | 场景类型 | 描述 | 
> |:----------:|:-------------- |
> |主键索引缺失 | 由于5.6版本以上使用的是聚簇索引表设计，要求所有的表必须要包含一个主键。|
> | 主键索引于业务相关 | 如果主键也业务相关，就会被频繁更新，从而引起InnoDB存储引擎进行频繁的节点合并和分裂，造成额外的I/O开销。建议新增与业务无关的自增字段作为主键，既能提高按时间顺序插入的性能同时也提高按插入时间范围检索的查询效率。 |
> |冗余索引 | 通过percona工具pt-duplicate-key-checker来检查，5.7版本通过sys库`schema_redundant_indexes`表分析|
> |无效索引 | 5.7版本通过sys库`schema_unused_indexes`视图分析|
> |低效索引 | 区分度不高，从而导致执行效率低。
> 

# 参考资料

* [MySQL性能监控](https://www.cnblogs.com/flish/p/4897176.html)
* [MySQL性能调优](https://www.cnblogs.com/claireyuancy/p/7258314.html)
* [MySQL常见索引及区别](https://www.cnblogs.com/shijianchuzhenzhi/p/6383117.html)
* 《云原生应用架构实践》（网易云基础服务架构团队）












